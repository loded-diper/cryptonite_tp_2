# buffer overflow 0
 

**Flag:** `picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}`

How you approached the challenge:
- On examining the source code, i found the sigsegv_handler function which will print the flag if a `SIGSEGV` or `SIGNAL SEGMENTATION VIOLATION` occurs.
- Now I only needed to trigger `SIGSEGV` , which can be achieved by buffer overflow.
- In the source code, two vulnerable functions are used, which are `gets` and `strcpy`, any of these can cause buffer overflow.
- If i input a string with more than 100 characters, the `gets` function in `main` will trigger `SIGSEGV`.
- If i input a string with more than 16 character, the `strcpy` function in `vuln` will trigger `SIGSEGV`
```bash
vishad@VISHAD:~$ nc saturn.picoctf.net 49889
Input: 123412341234123412341
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
```  
What you learned through solving this challenge:

1. Buffer Overflow

2. Signaling `SIGSEGV` using `signal` 

4. Difference between `gets` & `fgets`

5. Risky C function which can lead to security risks , like `gets` and `strcpy`

References
- https://owasp.org/www-community/attacks/Buffer_overflow_attack
- https://www.geeksforgeeks.org/segmentation-fault-sigsegv-vs-bus-error-sigbus/

- etc.


# format string 0

**Flag:**  `picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_f89c1405}`

  How you approached the challenge:
-  Upon examining the source code , I noticed there is `SIGSEGV` handler function , which means that a buffer overflow could leak the flag (as in the previous question), so i tried inputting a string with 48 characters & it fetched me the flag.
```bash
vishad@VISHAD:~$ nc mimas.picoctf.net 65521
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: 123456789123456789123456789123456789123456789123
There is no such burger yet!

picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_f89c1405}
```  


- I noticed `printf(choice1)` in the source code , which is a `format string vulnerability`, and different format specifiers like `%x %s etc` be used to extract data from stack memory leaking sensitive information.
- In the `serve_patrick` function , we need to input a burger name which should have characters more than `2*BUFSIZE` which is `64` to go to the next function `serve_bob` .
- Inputting any random string of more than 64 characters will not work because the `on_menu` function will check that it has to be out of the 3 given burgers.
- So I noticed `Gr%114d_Cheese` burger, which has a `%114d` in between it's string, is treated as a format specifier for `print` function which forces it to print `114` characters between `Gr` and `_cheese`.
- This makes the count have more than 64 characters `(123 to be exact)` and also passes the `on_menu` test & moves ahead to `serve_bob` 

```bash
vishad@VISHAD:~$ nc mimas.picoctf.net 65521
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
```
- Same logic is applied in the `serve_bob` function and I chose `Cla%sic_Che%s%steak` burger because `%s` is format string vulnerability and will leak sensitive information.
```bash
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_f89c1405}
```
What you learned through solving this challenge:
1. Format String Vulnerability

2. using `print` without format specifiers can be dangerous

3. `scanf` can also cause buffer overflows

Other incorrect methods you tried:

 - I tried to overflow the buffer by inputting 33 characters (because BUFSIZE was 32) , but it did not happen and simply printed `There is no such burger yet!`

References
- https://owasp.org/www-community/attacks/Format_string_attack